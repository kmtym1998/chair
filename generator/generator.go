package generator

import (
	"context"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sort"

	"github.com/dave/jennifer/jen"
	"github.com/kmtym1998/chair/generator/config"
)

type Generator struct {
	config         *config.Config
	defaultMappers []config.TypeMapping
	schemaLoader   SchemaLoader
}

func New(
	config *config.Config,
	defaultMappers []config.TypeMapping,
	schemaLoader SchemaLoader,
) *Generator {
	return &Generator{
		config:         config,
		defaultMappers: defaultMappers,
		schemaLoader:   schemaLoader,
	}
}

func (g *Generator) Run(ctx context.Context) error {
	// Load schema
	tables, err := g.schemaLoader.LoadTableSchemas(ctx)
	if err != nil {
		return err
	}

	// Create a new file
	file := jen.NewFile(g.config.PkgName)
	file.Comment("Code generated by github.com/kmtym1998/chair. DO NOT EDIT.").Line()

	// Generate code
	for _, table := range tables {
		stmt := g.generateTableStruct(table)
		file.Add(stmt)
	}

	// Write to file
	if err := g.export(file); err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateTableStruct(table Table) *jen.Statement {
	modelName := Field(table.Name).ToUpperCamel().ToSingular().String()

	structStmt := jen.Commentf("%s: %s", table.Name, table.Comment).Line()

	sort.SliceStable(table.Columns, func(i, j int) bool {
		return table.Columns[i].OrderAsc < table.Columns[j].OrderAsc
	})

	structFields := make([]jen.Code, len(table.Columns))
	for i, column := range table.Columns {
		structFields[i] = g.generateTableStructField(table, column, i == 0)
	}

	structStmt.Type().Id(modelName).Struct(structFields...)

	return structStmt
}

func (g *Generator) generateTableStructField(table Table, column Column, isFirstField bool) *jen.Statement {
	comment := func() string {
		if column.Comment == "" {
			return fmt.Sprintf("%s.%s", table.Name, column.Name)
		}

		return fmt.Sprintf("%s.%s: %s", table.Name, column.Name, column.Comment)
	}()

	var fieldStmt *jen.Statement
	if isFirstField {
		fieldStmt = jen.Comment(comment)
	} else {
		fieldStmt = jen.Line().Comment(comment)
	}

	return fieldStmt.
		Line().
		Id(Field(column.Name).
			ToUpperCamel().
			ToSingular().
			String(),
		).
		String()
}

func (g *Generator) export(file *jen.File) error {
	if filepath.Ext(g.config.Output) != ".go" {
		return errors.New("output file must be a .go file")
	}

	dir := filepath.Dir(g.config.Output)
	if _, err := os.Stat(dir); os.IsNotExist(err) {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	if _, err := os.Create(g.config.Output); err != nil {
		return err
	}

	return file.Save(g.config.Output)
}
