package generator

import (
	"context"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sort"

	"github.com/dave/jennifer/jen"
	"github.com/kmtym1998/chair/generator/config"
)

type Generator struct {
	config       *config.Config
	mappings     []config.TypeMapping
	schemaLoader SchemaLoader
}

func New(
	cfg *config.Config,
	defaultMappings []config.TypeMapping,
	schemaLoader SchemaLoader,
) *Generator {
	mappings := make([]config.TypeMapping, 0, len(defaultMappings)+len(cfg.Mappings))
	mappings = append(mappings, cfg.Mappings...)
	mappings = append(mappings, defaultMappings...)

	return &Generator{
		config:       cfg,
		schemaLoader: schemaLoader,
		mappings:     mappings,
	}
}

func (g *Generator) Run(ctx context.Context) error {
	// Load schema
	tables, err := g.schemaLoader.LoadTableSchemas(ctx)
	if err != nil {
		return err
	}

	// Create a new file
	file := jen.NewFile(g.config.PkgName)
	file.Comment("Code generated by github.com/kmtym1998/chair. DO NOT EDIT.").Line()

	// Generate code
	for _, table := range tables {
		stmt := g.generateTableStruct(table)
		file.Add(stmt)
	}

	// Write to file
	if err := g.export(file); err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateTableStruct(table Table) *jen.Statement {
	modelName := Field(table.Name).ToUpperCamel().ToSingular().String()

	comment := func() string {
		if table.Comment == "" {
			return table.Name
		}

		return fmt.Sprintf("%s: %s", table.Name, table.Comment)
	}()
	structStmt := jen.Comment(comment).Line()

	sort.SliceStable(table.Columns, func(i, j int) bool {
		return table.Columns[i].OrderAsc < table.Columns[j].OrderAsc
	})

	structFields := make([]jen.Code, len(table.Columns))
	for i, column := range table.Columns {
		structFields[i] = g.generateTableStructField(table, column, i == 0)
	}

	structStmt.Type().Id(modelName).Struct(structFields...)

	return structStmt
}

func (g *Generator) generateTableStructField(table Table, column Column, isFirstField bool) *jen.Statement {
	comment := func() string {
		if column.Comment == "" {
			return fmt.Sprintf("%s.%s", table.Name, column.Name)
		}

		return fmt.Sprintf("%s.%s: %s", table.Name, column.Name, column.Comment)
	}()

	var fieldStmt *jen.Statement
	if isFirstField {
		fieldStmt = jen.Comment(comment)
	} else {
		fieldStmt = jen.Line().Comment(comment)
	}

	fieldStmt.
		Line().
		Id(Field(column.Name).
			ToUpperCamel().
			String(),
		)

	mapping, ok := g.findMappingByDBType(column.Type, column.IsNullable)
	if ok {
		fieldStmt.Qual(mapping.GoPkg, mapping.GoType)
	} else {
		fieldStmt.Interface()
	}

	return fieldStmt
}

func (g *Generator) export(file *jen.File) error {
	if filepath.Ext(g.config.Output) != ".go" {
		return errors.New("output file must be a .go file")
	}

	dir := filepath.Dir(g.config.Output)
	if _, err := os.Stat(dir); os.IsNotExist(err) {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	if _, err := os.Create(g.config.Output); err != nil {
		return err
	}

	return file.Save(g.config.Output)
}

func (g *Generator) findMappingByDBType(dbType string, isNullable bool) (config.TypeMapping, bool) {
	var mapping config.TypeMapping
	for _, m := range g.mappings {
		if m.DBType == dbType && m.IsNullable == isNullable {
			mapping = m
			return mapping, true
		}
	}

	return mapping, false
}
