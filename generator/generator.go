package generator

import (
	"context"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sort"

	"github.com/dave/jennifer/jen"
	"github.com/kmtym1998/chair/generator/config"
)

type Generator struct {
	config         *config.Config
	defaultMappers []config.TypeMapping
	schemaLoader   SchemaLoader
	file           *jen.File
}

func New(
	config *config.Config,
	defaultMappers []config.TypeMapping,
	schemaLoader SchemaLoader,
) *Generator {
	file := jen.NewFile(config.PkgName)
	file.Comment("Code generated by github.com/kmtym1998/chair. DO NOT EDIT.").Line()

	return &Generator{
		config:         config,
		defaultMappers: defaultMappers,
		schemaLoader:   schemaLoader,
		file:           file,
	}
}

func (g *Generator) Run(ctx context.Context) error {
	// Load schema
	tables, err := g.schemaLoader.LoadTableSchemas(ctx)
	if err != nil {
		return err
	}

	// Generate code
	for _, table := range tables {
		g.generateTableStruct(table)
	}

	// Write to file
	if err := g.write(); err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateTableStruct(table Table) {
	file := g.file

	modelName := Field(table.Name).ToUpperCamel().ToSingular().String()
	file.Commentf("%s: %s", table.Name, table.Comment)

	sort.SliceStable(table.Columns, func(i, j int) bool {
		return table.Columns[i].OrderAsc < table.Columns[j].OrderAsc
	})

	structFields := make([]jen.Code, len(table.Columns))
	for i, column := range table.Columns {
		comment := func() string {
			if column.Comment == "" {
				return fmt.Sprintf("%s.%s", table.Name, column.Name)
			}

			return fmt.Sprintf("%s.%s: %s", table.Name, column.Name, column.Comment)
		}()

		var fieldStmt *jen.Statement
		if i == 0 {
			fieldStmt = jen.Comment(comment)
		} else {
			fieldStmt = jen.Line().Comment(comment)
		}

		structFields[i] = fieldStmt.
			Line().
			Id(Field(column.Name).
				ToUpperCamel().
				ToSingular().
				String(),
			).
			String()
	}

	file.Type().Id(modelName).Struct(structFields...)
}

func (g *Generator) write() error {
	if filepath.Ext(g.config.Output) != ".go" {
		return errors.New("output file must be a .go file")
	}

	dir := filepath.Dir(g.config.Output)
	if _, err := os.Stat(dir); os.IsNotExist(err) {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	if _, err := os.Create(g.config.Output); err != nil {
		return err
	}

	return g.file.Save(g.config.Output)
}
